'use strict';

var https = require('https');
var zlib = require('zlib');

/**
 * Server-side https request
 * @param options {Object}
 *   options.request {Object} - Request data including method, host and path
 *   options.timeout {Number} - Request timeout before returning an error. Defaults to 30000 milliseconds
 *   options.fmt {String} - Return results in html or json format (useful for viewing responses as GIFs to debug/test)
 *   options.postData {Object} - Post data to be written to request stream
 */

exports.request = function (options, resolve, reject) {
  var timeout = options.timeout;
  var format = options.fmt;

  var req = https.request(options.request, function (res) {
    switch (res.headers['content-encoding']) {
      case 'gzip' || 'deflate':
        var output = zlib.createUnzip();
        res.pipe(output);
        break;
      default:
        var output = res;
        break;
    }

    var body = '';

    output.on('data', function (d) {
      body += d;
    });

    output.on('end', function () {
      if (format !== 'html') {
        if (typeof body === 'undefined' || !body) {
          body = {};
        } else {
          try {
            body = JSON.parse(body);
          } catch (e) {
            console.log('error parsing json', e);
            console.log('body', body);
            body = body;
          }
        }
      }
      body.statusCode = res.statusCode;

      if (res.statusCode >= 400 && res.statusCode < 500) {
        return reject(body);
      }

      return resolve(body);
    });

    output.on('error', function (err) {
      return reject(err);
    });
  });

  req.on('error', function (err) {
    return reject(err);
  });

  req.on('socket', function (socket) {
    socket.setTimeout(timeout);
    socket.on('timeout', function () {
      req.abort();
    });
  });

  if (options.postData) {
    req.write(JSON.stringify(options.postData));
    req.end();
  } else {
    req.end();
  }
};