'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*jslint node: true */

var _http2 = require('./util/_http');

var _http3 = _interopRequireDefault(_http2);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var tokenSymbol = Symbol();

/**
 *  Gfycat API wrapper class
 */

var Gfycat = function () {

  /**
   *  Create a Gfycat SDK object.
   *  @param {string} clientId - Client id retrieved from the developers portal.
   *  @param {string} clientSecret - Client secret retrieved from the developers portal.
   */
  function Gfycat() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        clientId = _ref.clientId,
        clientSecret = _ref.clientSecret;

    _classCallCheck(this, Gfycat);

    this.apiUrl = 'api.gfycat.com';
    this.apiVersion = '/v1';
    this.promiseSupport = typeof Promise !== 'undefined';
    this[tokenSymbol] = '';

    if (!!clientId) this.clientId = clientId;
    if (!!clientSecret) this.clientSecret = clientSecret;
  }

  /**
   *  Authenticate using client id and secret, and store the retrieved access token in the class instance to be used implicitly by other methods.
   *  @callback {callback} [callback] - Optional callback function to be executed upon API response.
   *  @return {}
   */


  _createClass(Gfycat, [{
    key: 'authenticate',
    value: function authenticate(callback) {
      var _this = this;

      var postData = {
        grant_type: 'client_credentials',
        client_id: this.clientId,
        client_secret: this.clientSecret,
        scope: 'scope' // Currently does not do anything
      };

      var options = {
        path: '/oauth/token',
        method: 'POST',
        postData: postData
      };

      if (callback) {
        this._request(options, function (err, data) {
          if (err) {
            return callback(err);
          } else {
            _this[tokenSymbol] = data.access_token;
            return callback(null, data);
          }
        });
      } else {
        return new Promise(function (resolve, reject) {
          _this._request(options, function (err, data) {
            if (err) reject(err);else {
              _this[tokenSymbol] = data.access_token;
              resolve(data);
            }
          });
        });
      }
    }

    /**
     * Checking if the username is available / username exists / username is valid
     */

  }, {
    key: 'checkUsername',
    value: function checkUsername() {
      var _this2 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$username = _ref2.username,
          username = _ref2$username === undefined ? '' : _ref2$username;

      var callback = arguments[1];

      if (typeof username === 'undefined' || !username || username.length === 0) {
        return this.handleError('invalid username', callback);
      }

      var options = {
        path: '/users/' + username,
        method: 'GET'
      };

      if (callback) {
        this._request(options, function (err, data) {
          if (data) {
            return callback(null, false);
          } else {
            if ([401, 403, 422].indexOf(err.statusCode) > -1) {
              return callback(err);
            } else {
              return callback(null, true);
            }
          }
        });
      } else {
        return new Promise(function (resolve, reject) {
          _this2._request(options, function (err, data) {
            if (data || [401, 422].indexOf(err.statusCode) > -1) {
              resolve(false);
            } else if (err && err.statusCode === 404) {
              resolve(true);
            } else {
              reject(err);
            }
          });
        });
      }
    }

    /**
     *  Search
     *
     *  @param {Object}  
     */

  }, {
    key: 'search',
    value: function search() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          search_text = _ref3.search_text,
          _ref3$random = _ref3.random,
          random = _ref3$random === undefined ? false : _ref3$random,
          _ref3$count = _ref3.count,
          count = _ref3$count === undefined ? 1 : _ref3$count,
          cursor = _ref3.cursor,
          first = _ref3.first;

      var callback = arguments[1];

      if (typeof search_text === 'undefined') {
        return this.handleError('Please specify a search_text attribute.', callback);
      }

      if (!!cursor && !!first) {
        return this.handleError('Please do not specify both cursor and first attributes. Only use one or the other.', callback);
      }

      var queryParams = {
        search_text: search_text,
        count: count
      };

      if (random) queryParams.random = true;
      if (cursor) queryParams.cursor = cursor;
      if (first) queryParams.first = first;

      var options = {
        path: '/gfycats/search',
        method: 'GET',
        query: queryParams
      };

      return this._request(options, callback);
    }

    /**
     * Get User info by ID
     */

  }, {
    key: 'getUserDetails',
    value: function getUserDetails() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userId = _ref4.userId;

      var callback = arguments[1];

      if (typeof userId === 'undefined' || userId === null || userId.length === 0) {
        return this.handleError('invalid userId', callback);
      }

      var options = {
        path: '/users/' + userId,
        method: 'GET'
      };

      return this._request(options, callback);
    }

    /**
     * Get Gfy info by ID
     */

  }, {
    key: 'getGifDetails',
    value: function getGifDetails() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          gfyId = _ref5.gfyId;

      var callback = arguments[1];

      if (typeof gfyId === 'undefined' || gfyId === null || gfyId.length === 0) {
        return this.handleError('invalid gfyId', callback);
      }

      var options = {
        path: '/gfycats/' + gfyId,
        method: 'GET'
      };

      return this._request(options, callback);
    }

    /**
     * User feed 
     */

  }, {
    key: 'userFeed',
    value: function userFeed() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          userId = _ref6.userId;

      var callback = arguments[1];

      if (typeof userId === 'undefined' || userId === null || userId.length === 0) {
        return this.handleError('invalid gfyId', callback);
      }

      var options = {
        path: '/users/' + userId + '/gfycats',
        method: 'GET'
      };

      return this._request(options, callback);
    }

    /**
     *  Trending
     */

  }, {
    key: 'trendingGifs',
    value: function trendingGifs() {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$count = _ref7.count,
          count = _ref7$count === undefined ? 1 : _ref7$count;

      var callback = arguments[1];


      var options = {
        path: '/gfycats/trending',
        method: 'GET',
        query: { count: count }
      };

      return this._request(options, callback);
    }

    /**
     *  Trending tags
     */

  }, {
    key: 'trendingTags',
    value: function trendingTags(opts, callback) {
      var path = '/tags/trending';
      if (!opts) opts = {};
      if (opts.populated) path += '/populated';
      // if (opts.cursor) queryParams.cursor = cursor;

      var options = {
        path: path,
        method: 'GET',
        query: opts
      };

      return this._request(options, callback);
    }

    /**
     *  Upload by URL
     */

  }, {
    key: 'upload',
    value: function upload(opts, callback) {
      if (!opts) return this.handleError('invalid Object', callback);

      var options = {
        path: '/gfycats',
        method: 'POST',
        postData: opts
      };

      return this._request(options, callback);
    }

    /**
     *  Check upload status
     */

  }, {
    key: 'checkUploadStatus',
    value: function checkUploadStatus(gfyId, callback) {
      var options = {
        path: '/gfycats/fetch/status/' + gfyId,
        method: 'GET'
      };

      return this._request(options, callback);
    }
  }, {
    key: 'handleError',
    value: function handleError(message, callback) {
      if (callback) return callback(new Error(message));else return Promise.reject(new Error(message));
    }

    /**
     *  Helper function for making http requests
     */

  }, {
    key: '_request',
    value: function _request(options, callback) {
      if (!callback && !this.promiseSupport) {
        throw new Error('Promises unsupported. Use callback functions instead.');
      }

      var query = typeof options.query !== 'undefined' ? _querystring2.default.stringify(options.query) : '';
      var apiPath = query ? options.path + '?' + query : options.path;

      var headers = {
        'Accept-Encoding': 'gzip,deflate'
      };

      if (this[tokenSymbol]) headers.Authorization = 'Bearer ' + this[tokenSymbol];

      if (options.headers) {
        headers = Object.assign(headers, options.headers);
      }

      var httpOptions = {
        request: {
          hostname: this.apiUrl,
          path: this.apiVersion + apiPath,
          method: options.method || 'GET',
          headers: headers
        },
        postData: options.postData || '',
        timeout: options.timeout || 30000,
        fmt: options.query && options.query.fmt
      };

      //If callback function is provided, override promise handlers.
      if (callback) {
        var resolve = function resolve(res) {
          callback(null, res);
        };

        var reject = function reject(err) {
          callback(err);
        };
        _http3.default.request(httpOptions, resolve, reject);
      }

      //If no callback function is provided and promises are supported, use them.
      else {
          return new Promise(function (resolve, reject) {
            _http3.default.request(httpOptions, resolve, reject);
          });
        }
    }
  }]);

  return Gfycat;
}();

exports.default = Gfycat;